1.异常 ERROR
1.1 对于异常的处理
	1) 代码逻辑的错误导致(bug)
		修改代码
	2) 调用外部接口或者统一处理异常时,需要捕捉异常
	3) 异常只能被捕获一次,并且逐级的向上传递
		如果一直没有被捕获,那么会被系统捕获到
1.2 捕捉异常的语法:
	try{
		//可能出现异常的代码
		}catch(e){
		//e:捕捉到的异常
		//异常的处理
		} finally{
		//无论如何都要执行的代码
		}
1.3 异常的类型:
	SyntaxError  语法错误
	ReferenceError  引用错误
	TypeError	类型错误
	RangeError  范围错误
	EvalError	调用eval函数时错误
	URLError	Url错误

1.4 抛出异常 throw   
	可以自定义异常
	throw new Error("自定义创建的新的异常");
	throw e; //抛出系统异常

2. eval函数
执行有正确代码格式的字符串
	eg:
	console.log("hello world");

	eval('console.log("hello world");');  //执行有正确代码格式的字符串

<!-- 重点 -->
3.面向对象
	OOP(Object Oriented Programming)
3.1 对象的概念
	在程序用一个对象来描述显示中的物体(万物皆对象)
	包含 属性和功能
	属性:
	用来描述一个物体的特性值(特征).
	功能:
	用来描述一个物体的可以执行的操作,在程序中就是函数(行为).

	什么是对象?
	在程序中,无序属性和功能的集合就是对象

3.2 面向对象的三大特点:
	1.封装
		把属性与功能集中在一起,来描述对象,为了方便代码重用
	2.继承
		父对象中的成员,可以被子对象继承,这样既可以重用,又可以节约时间
	3.多态
		同一个方法在不同情况下有不同的状态
		为了体现子对象和父对象之间的差异

3.3 对象声明
	1)直接量 
		var 对象名 ={对象,对象,功能,功能...}
	2)new 
		var 对象名 = new Object();
		new 是把类型实例化,就是按照模板创建一个新对象
	3)工厂模式
		相较于前两种方式,工厂模式更规范,
		它是把 对象规范特性提取 和 对象属性的赋值 分开
	4)构造函数
		4.1 允许自定义一个新类型,然后用new创建一个新类型的对象

		4.2 是一个函数,但其表示的实际是一个类型
		4.3 构造方法一般不做普通方法调用,而是和内置类型一样,
			 与new配合使用,用来创建一个新对象

			 *自定义构造函数不能当做普通函数调用,要用new配合,不然会导致this指向不明

		4.4 构造方法一般用大写字符开头
3.4 new 关键字

自使用new的时候,实际上做了四件事
	1. 创建了一个空对象(Object)(与工厂函数做的事情类型)
	2. 将构造函数的作用域分配给了新对象(就是构造函数内部的this指向了这个新对象)
	3. 将新对象的_proto_属性指向了构造函数的原型对象(继承父类)
	4. 执行构造函数中的代码

3.5 继承
	子对象 把 父对象 的所有成员拿来作为自己的成员
	js中的继承是通过  原型链  来实现的
	原型链事件的原理:
		在所有对象的成员上通通加上一个叫做原型对象的属性prototype,
		当一个属性在原有成员不存在时,js会自动到prototype上面去找.
		//每个构造函数都有一个内置属性,叫做prototype
		console.log(Stu.prototype);
		Stu.prototype.score = 100;
	

3.5.1 原型链 
	1) 任何对象都有 __proto__ 继承父对象,由各级父对象逐级继承,实现的链式结构叫做原型链
	2) 修改原型链的父类对象:
		类型.prototype = 父对象; 与 对象.__proto__=父对象;
	3) Object.prototype是所有对象的顶级父对象
		他的父对象是null
	4) Function.prototype是所有函数的父对象
		他的父对象是 Object.prototype
	5) 原型链的成员使用顺序:
		先用自己的-->自己没有找父类-->父类没有再逐级往父类上找
		如果找不到返回返回undefined